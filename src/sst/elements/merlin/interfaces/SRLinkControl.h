// TODO: copyright goes here?

// Original author of this code: Ziyue.Zhang@UGent.be, github user @ziyuezzy

// This class is meant to be a sibling class of LinkControl and ReorderLinkControl
// it provides a feature that supports source routing -- the path of a packet is determined at the source Endpoint or at the NIC
// The available paths are included in a 'routing table',
// The routing table is either read from an external file or generated by an algorithm


#ifndef COMPONENTS_MERLIN_SRLINKCONTROL_H
#define COMPONENTS_MERLIN_SRLINKCONTROL_H

#include <sst/core/interfaces/simpleNetwork.h>
#include <sst/core/subcomponent.h>
#include "reorderLinkControl.h"

// #include <sst/core/unitAlgebra.h>
// #include <sst/core/statapi/statbase.h>
// #include "sst/elements/merlin/router.h"

#include <queue>
#include <unordered_map>


namespace SST {

class Component;

namespace Merlin {

// Class SRLinkControl (Source Routing LinkControl)
// Designed and implemented by Ziyue Zhang (UGent-IDLab, FWO), GitHub @ziyuezzy
class SRLinkControl : public SST::Interfaces::SimpleNetwork
{
public:

    SST_ELI_REGISTER_SUBCOMPONENT(
        SRLinkControl,
        "merlin",
        "srlinkcontrol",
        SST_ELI_ELEMENT_VERSION(1,0,0),
        "A Link Control module that can handle source routing, out of order packet arrival can also be supported (utilizes merlin.reorderlinkcontrol).",
        SST::Interfaces::SimpleNetwork
    )

    SST_ELI_DOCUMENT_PARAMS(
        // {"rlc.networkIF","SimpleNetwork subcomponent to be used for connecting to network", "merlin.linkcontrol"}, // I don't really understand this now
        {"networkIF","SimpleNetwork subcomponent to be used for connecting to network", "merlin.linkcontrol"}
    )

    SST_ELI_DOCUMENT_PORTS(
        {"rtr_port", "Port that connects to router", { "merlin.RtrEvent", "merlin.credit_event", "" } },
    )

    SST_ELI_DOCUMENT_SUBCOMPONENT_SLOTS(
        {"networkIF", "Network interface", "SST::Interfaces::SimpleNetwork" }
    )

    SRLinkControl();
    ~SRLinkControl();
    void setup();
    void init(unsigned int phase);
    void complete(unsigned int phase);
    void finish();

    // Returns true if there is space in the output buffer and false
    // otherwise.
    bool send(SST::Interfaces::SimpleNetwork::Request* req, int vn);

    // Returns true if there is space in the output buffer and false
    // otherwise.
    bool spaceToSend(int vn, int flits);

    // Returns NULL if no event in input_buf[vn]. Otherwise, returns
    // the next event.
    SST::Interfaces::SimpleNetwork::Request* recv(int vn);

    // Returns true if there is an event in the input buffer and false
    // otherwise.
    bool requestToReceive( int vn );

    void sendUntimedData(SST::Interfaces::SimpleNetwork::Request* ev);
    SST::Interfaces::SimpleNetwork::Request* recvUntimedData();

    void setNotifyOnReceive(HandlerBase* functor);
    void setNotifyOnSend(HandlerBase* functor);

    bool isNetworkInitialized() const;
    nid_t getEndpointID() const;
    const UnitAlgebra& getLinkBW() const;
private:
    int vns;
    SST::Interfaces::SimpleNetwork* link_control;
    UnitAlgebra link_bw;
    int id;
    bool handle_event(int vn);
    // Functors for notifying the parent when there is more space in
    // output queue or when a new packet arrives
    HandlerBase* receiveFunctor;
};

// Class SRRequest (Source Routing Request), wraps around ReorderRequest
// Designed and implemented by Ziyue Zhang (UGent-IDLab, FWO), GitHub @ziyuezzy
class SRRequest : public ReorderRequest{
public:
    // the pre-determined path for source routing, stored as a list of router ids,
    // this will be indexed by the num_hops variable in topo_any_event to get the next hop router id
    std::vector<int> path;

    // in a SRv6 header, the 'segment left' field indicates the number of remaining hops, but here we can just use the 'num_hops' variable in topo_any_event
    // int segment_left;

    SRRequest() : ReorderRequest() { path.clear(); }
    ~SRRequest() {}

    void serialize_order(SST::Core::Serialization::serializer &ser)  override {
        SST::Interfaces::SimpleNetwork::Request::serialize_order(ser);
        SST_SER(path);
    }

};

}
}

#endif